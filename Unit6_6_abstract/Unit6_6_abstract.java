package Unit6_6_abstract;

/**
 * 抽象是什么
 * 需求---不同动物 吃的东西不一样 // 但都有共同点--睡觉&跑步 ---但是睡觉的姿势、跑步的方法速度 又有差距
 * 即 有些方法一样 但有些方法不一样---都要吃/睡觉/跑步（但具体的内容有差别）---抽象
 *
 */

/**
 * 父类只需要【定义】抽象方法run()--run是抽象的--加【abstract】关键字
 * 但是父类并没有实现抽象方法---具体由子类通过@Override实现
 *

/**
 * 1.抽象类
 * abstract class 类名 {
 * }
 * 【抽象类的特点】
 * 0. 【抽象类不能被实例化】---因为抽象类的方法没有被实例化-->不完整的类
 *    所以不能new【抽象类的对象】---抽象类的方法也是抽象方法--没被实现（编译失败）
 * a. 有abstract方法--->必须有abstract类
 *    但是
 *    有abstract类--不一定有abstract方法
 *    *** 当抽象类里面并没有抽象方法，但声明成了abstract类--> 此类不能被实例化
 *
 * b. 抽象类的子类【必须去实现抽象方法】的具体实现--否则，不重写抽象方法，继承抽象方法-->仍然不能实例化
 *
 * c. abstract类【不能用final关键字修饰】---无法被继承
 *  * 【如果不想被继承，那要抽象干什么】
 *
 * 2.抽象方法
 * abstract 类型 方法名(){
 * }
 *【抽象方法的特点】
 * a. 抽象类中--抽象方法--【只声明，不包含方法体】。
 * b. 抽象方法【不能用private修饰】，因为抽象方法必须被子类实现（覆写）---private的权限，子类不可访问
 * c. 子类extends抽象类--则子类必须【全部覆写】抽象类的抽象方法
 *    ** 【若不全部覆写】，则子类也必须声明为抽象类

 *
 */


public class Unit6_6_abstract {
}
